OSCAR DIAZ SALDAÑA - 3º COMPUTADORES

BUENAS, SE VA A EXPLICAR EL DESARROLLO DEL DRIVER DEL MODULO BERRYCLIP
EN UNA PLACA RPI, EN CONCRETO LA PLACA RPI 3B+.

LA PLACA BERRYCLIP ES UN MODULO CON 6 LEDS (2 VERDES, 2 AMARILLOS Y 
2 ROJOS), 1 SPEAKER Y 2 BOTONES. ESTOS PERIFERICOS VAN CONECTADOS POR 
PINES QUE OFRECE LA PLACA RPI. EN CONCRETO, ESTOS PINES SON:

BUTTON 1: 		PIN 2 	ENTRADA
BUTTON 2: 		PIN 3 	ENTRADA
SPEAKER: 		PIN 4 	SALIDA
LED VERDE 1: 	PIN 27 	SALIDA
LED VERDE 2: 	PIN 22 	SALIDA
LED AMARILLO 1: PIN 17 	SALIDA
LED AMARILLO 2: PIN 11 	SALIDA
LED ROJO 1: 	PIN 10 	SALIDA
LED ROJO 2: 	PIN 9 	SALIDA

NOMBRE DEL ARCHIVO CON LA LOGICA DEL DRIVER: driver-RPI.c

INSTALACION DEL MODULO:

	CREAR MODULO: MODULE=driver-RPI make
	INSTALAR MODULO: POR DEFECTO, 250MS DE TIEMPO ESPERA INTERRUPCION 
					 BOTONES
						sudo insmod driver-RPI.ko
					 PERSONALIZADO, TIEMPO DE ESPERA INTERRUPCION 
					 BOTONES EJEMPLO: 2 SEGUNDOS
						sudo insmod driver-RPI.ko tiempo=2000
	DESINSTALAR MODULO: sudo rmmod driver-RPI
	
CONSULTA DEL MODULO:
	CONSULTAR MODULO EN LA LISTA: lsmod
	VER MENSAJES DE KERNEL: dmesg

EJEMPLO DE USO:

-LEDS:
	ESCRITURA: ./bin2char.sh 00110011 > /dev/leds
				// MODO 00 ENCIENDE LOS LEDS 6,5,2,1
			   ./bin2char.sh 01001011 > /dev/leds 
				// MODO 01 ENCIENDE LOS LEDS 4,2,1, RESTO IGUAL
			   ./bin2char.sh 10110111 > /dev/leds 
				// MODO 10 APAGA LOS LEDS 6,5,3,2,1, RESTO IGUAL
			   ./bin2char.sh 11001011 > /dev/leds 
			    // MODO 11 NO VALIDO
	LECTURA:   ./dev2bin.sh /dev/leds   
				// muestra en binario los leds EJ: 000011
-SPEAKER:
	ESCRITURA: echo '0' > /dev/leds
				//APAGA EL SPEAKER
			   echo '5' > /dev/leds 
			    //ENCIENDE EL SPEAKER
	PRUEBA:    COMPILAMOS ARCHIVO .C DE PRUEBA  
				gcc prueba_speaker2.c -o prueba_speaker2
			   EJECUTAMOS
				./prueba_speaker2
			   SUENA ALTAVOZ
-BUTTONS: 
	LECTURA:   DOS MANERAS DE EJECUCION:
				1 - PULSAMOS PRIMERO VARIOS BOTONES EJMEPLO: 21121
				 AHORA EJECUTAMOS: 
				  cat /dev/buttons 
			     MUESTRA
			      21121
			     PULSAMOS CTRL + C PARA SALIR
			     VACIA LA COLA
			    2 - LLAMAMOS A: cat /dev/buttons
					SE QUEDA BLOQUEADO ESPERANDO PULSACIONES
					PULSAMOS UN BOTON Y LO MUESTRA POR PANTALLA
					PULSAMOS CTRL + C PARA SALIR
	PRUEBA:    COMPILAMOS LA PRUEBA 
				gcc lee_buttons.c -o lee_buttons
			   EJECUTAMOS
			    ./lee_buttons
			   NOS MUESTRA UN MENSAJE DEL PROCESO QUE ABRE EL FICHERO
			   Y SE QUEDA ESPERANDO 5 PULSACIONES, EJEMPLO:
				Abriendo fichero /dev/buttons por pid 7380
				Leida pulsación #0 = '1' por pid 7380
				Leida pulsación #1 = '1' por pid 7380
				Leida pulsación #2 = '2' por pid 7380
				Leida pulsación #3 = '2' por pid 7380
				Leida pulsación #4 = '1' por pid 7380
				Cerrando fichero por pid 7380
				

BREVE EXPLICACION DESARROLLO:

/***********************************************************************
LEDS
***********************************************************************/
ESTE PERIFERICO VA A RECIBIR UN BYTE, LOS DOS ALTOS ELIGEN EL MODO Y
LOS 6 BAJOS ELIGEN EL LED SELECCIONADO. ESTOS MODOS SON:

00 : NORMAL, 0 APAGADO 1 ENCENDIDO
01 : ENCIENDE 1, SE MODIFICAN SOLO LOS BITS A 1 ENCENDIENDOLOS, LOS QUE 
ESTAN A 0 NO SE MODIFICAN
10 : APAGA 1, SE MODIFICAN SOLO LOS BITS A 1 APAGANDOLOS, LOS QUE 
ESTAN A 0 NO SE MODIFICAN
11 : MODO NO VALIDO

POR LO TANTO, TENEMOS QUE MODIFICAR EL METODO DE ESCRITURA DEL LED, 
CAPTURAMOS LA ENTRADA Y COGEMOS LOS DOS BITS MAS ALTOS Y CON ELLOS 
CREAMOS CONDICIONES PARA ELEGIR CADA MODO. EN EL MODO 00 TENEMOS
QUE LEER LOS BITS Y PONERLOS A 0 (APAGADO) O 1 (ENCENDIDO). EN EL MODO 
01 TENEMOS QUE COMPROBAR SI CADA BIT ESTA A 1 Y SI LO ESTA LO 
ENCENDEMOS, DEJANDO LOS BITS A 0 COMO ESTABAN. EN EL MODO 10, 
COMPROBAMOS SI CADABIT ESTA A 1 Y SI LO ESTA LO APAGAMOS, DEJANDO LOS 
BITS A 0 COMO ESTABAN. ESCRIBIMOS CON EL ARCHIVO ./bin2char.sh

PARA LA LECTURA DEBEMOS DE LEER LOS GPIO DE CADA LED Y DEVOLVER ESA 
INFORMACION EN FORMA DE MENSAJE, LEYENDOLO CON EL ARCHIVO DE PARA ELLO
./dev2bin.sh

/***********************************************************************
ALTAVOZ
***********************************************************************/
ESTE PERIFERICO SERA UNICAMENTE DE ESCRITURA, TENEMOS QUE CONFIGURAR SU
METODO DE ESCRITURA. DE MODO QUE CUANDO ESCRIBAMOS UN 0 SE APAGARA EL 
ALTAVOZ Y NO PODRA REPRODUCIR SONIDOS. Y CUANDO ESTE A UN VALOR DISTINTO
PODRA REPRODUCIR SONIDOS.

DE MODO QUE COGEMOS DE USUARIO EL VALOR RECIBIDO Y ESTABLECEMOS EL VALOR
AL GPIO DEL PERIFERICO.

/***********************************************************************
BOTONES
***********************************************************************/
ESTE PERIFERICO SERA UN POCO DISTINTO SIMULANDO EL COMPORTAMIENTO DE 
UN TECLADO, PARA EVITAR LOS REBOTES DEL PULSADOR Y COLOCAR LOS VALORES 
DE CADA BOTON EN UNA COLA FIFO.

DEBEMOS COMENZAR BLOQUEANDO LOS PROCESOS CON UN SEMAFORO PARA QUE NO
MODIFIQUEN LA VARIABLE COMPARTIDA. RECOGEMOS LA LONGITUD DE LA COLA Y
LA MOSTRAMOS AL USUARIO.

USAMOS INTERRUPCIONES PARA QUE CUANDO SE PULSE EL BOTON LLAME A UNA 
INTERRUPCION PARA AVISAR AL SISTEMA OPERATIVO, EN ESTA INTERRUPCION 
DEBEMOS DE DESACTIVAR LAS INTERRUPCIONES PARA QUE OTRA NO INTERRUMPA A 
ESTA. PARA NO TENER REBOTES UTILIZAMOS UN TIMER CON 250MS (TIEMPO 
MINIMO DE RESPUESTA HUMANA) Y TAMBIEN SE LE PUEDE PASAR POR PARAMETROS.
CON UNA TAREA PROGRAMADA TASKLET PLANIFICAMOS LA ESCRITURA EN LA COLA 
FIFO, PONIENDO UN 1 O 2 DEPENDIENDO DEL BOTON PULSADO, TODO CONTROLADO 
POR SEMAFOROS.






























